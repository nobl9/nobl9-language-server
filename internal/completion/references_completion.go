package completion

import (
	"github.com/nobl9/nobl9-go/manifest"

	"github.com/nobl9/nobl9-language-server/internal/files"
	"github.com/nobl9/nobl9-language-server/internal/messages"
	"github.com/nobl9/nobl9-language-server/internal/sdkdocs"
	"github.com/nobl9/nobl9-language-server/internal/yamlastsimple"
	"github.com/nobl9/nobl9-language-server/internal/yamlpath"
)

type objectsRepo interface {
	GetAllNames(kind manifest.Kind, project string) []string
}

type docsProvider interface {
	GetProperty(kind manifest.Kind, path string) *sdkdocs.PropertyDoc
}

type refProviderFunc func() []messages.CompletionItem

func NewReferencesCompletionProvider(refProvider *ObjectsRefProvider) *ReferencesCompletionProvider {
	config := []struct {
		Path      string
		Kinds     []manifest.Kind
		Providers []refProviderFunc
	}{
		{
			Path:  "$.metadata.project",
			Kinds: projectScopedKinds,
			Providers: []refProviderFunc{
				refProvider.CompleteProjectName,
			},
		},
	}
	providers := make(map[string][]refProviderFunc, len(config))
	for _, c := range config {
		if len(c.Kinds) == 0 {
			providers[c.Path] = c.Providers
			continue
		}
		for _, kind := range c.Kinds {
			providers[refProviderKey(kind, c.Path)] = c.Providers
		}
	}
	return &ReferencesCompletionProvider{providers: providers}
}

type ReferencesCompletionProvider struct {
	// providers is a map of kind and path to a list of completion provider functions.
	// The key is generated by the [refProviderKey] function.
	providers map[string][]refProviderFunc
}

func (p ReferencesCompletionProvider) getType() completionProviderType {
	return valuesCompletionType
}

func (p ReferencesCompletionProvider) Complete(
	params messages.CompletionParams,
	_ files.SimpleObjectFile,
	node *files.SimpleObjectNode,
	line *yamlastsimple.Line,
) []messages.CompletionItem {
	path := yamlpath.NormalizeRootPath(line.Path)
	items := make([]messages.CompletionItem, 0)
	providers := p.lookupProviders(node.Kind, path)
	for _, providerFunc := range providers {
		items = append(items, providerFunc()...)
	}
	if charPtr := params.CompletionContext.TriggerCharacter; charPtr != nil && *charPtr == ":" {
		for i := range items {
			items[i].Label = " " + items[i].Label
		}
	}
	return items
}

func (p ReferencesCompletionProvider) lookupProviders(kind manifest.Kind, path string) []refProviderFunc {
	providers := p.providers[refProviderKey(kind, path)]
	kindLessProviders := p.providers[path]
	providers = append(providers, kindLessProviders...)
	return providers
}

func refProviderKey(kind manifest.Kind, path string) string {
	return kind.String() + "/" + path
}

// projectScopedKinds is a list of kinds that are scoped to a specific project.
var projectScopedKinds = []manifest.Kind{
	manifest.KindSLO,
	manifest.KindService,
	manifest.KindAgent,
	manifest.KindAlertPolicy,
	manifest.KindAlertSilence,
	manifest.KindProject,
	manifest.KindAlertMethod,
	manifest.KindDirect,
	manifest.KindDataExport,
	manifest.KindAnnotation,
}
